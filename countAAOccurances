# PURPOSE: Load in a fastq file, extract substrate sequences, and count AA
           # occurrences at each position in the substrates
    # IMPORTANT: File names must include information regarding the direction of expression
        # Forward Read: denoted by "R1"
        # Reverse Read: denoted by "R2"


import sys
import time
import pandas as pd
import pickle as pic
import warnings
import numpy as np
from Bio import SeqIO
from Bio.Seq import Seq
from Bio import BiopythonWarning
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap


# Record start time
startTime = time.time()


# ====================================== User Inputs ======================================

# INPUT 1: File Location Information
inFilePath = '/Users/PickMe/Documents/NGS/Mpro/Fasta'  # Define file pathway
inFileName = ['Mpro1_R4_S3_L002_R1_001', 'Mpro1_R4_S3_L002_R2_001']  # Define file name(s)
inSaveFileName = 'Mpro1_R4_S3_L002'
inSavePath = '/Users/PickMe/Documents/NGS/Mpro/Counts/'

# INPUT 2: Substrate parameters
inSubstrateLength = 8  # Define the length of the substrate

# INPUT 3: Define variables used to extract the substrate
inPrintNumberOfSubstrates = 10 # Print peptide sequences to validate substrate extraction
inFileType = 'fasta' # Define the type of file that contains your data
if '_R1_' in inFileName:  # Define sequences that flank
    inStartSeq = 'KGS'
    inEndSeq = 'GGSGG'
elif '_R2_' in inFileName:
    inStartSeq = 'KGS'
    inEndSeq = 'GGSGG'

# Input: Plotting the data
inPrintCounts = 0
inPlotCounts = 1
inPlotLabelSize = 15
inPlotTitleSize = 18
inPrintResideName = 1 # Set = 1, to print the full residue name on the plot
inPlotResidueLabels = ['R1', 'R2', 'R3', 'R4', 'R5', 'R6',  'R7', 'R8']
inCountsColorMap = ['white', 'tomato', 'red', 'red', 'firebrick', 'firebrick', 'darkred']  # Define the colors for the colormap


# ================================== Setup Residue List ==================================

# Set up the structure containing the residues in a tuple
residues = (('Alanine', 'A'), ('Arginine', 'R'), ('Asparagine', 'N'), \
            ('Aspartic Acid', 'D'), ('Cysteine', 'C'), ('Glutamic Acid', 'E'), \
            ('Glutamine', 'Q'), ('Glycine', 'G'), ('Histidine', 'H'), \
            ('Isoleucine', 'I'), ('Leucine', 'L'), ('Lysine', 'K'), ('Methionine', 'M'), \
            ('Phenylalanine', 'F'), ('Proline', 'P'), ('Serine', 'S'), ('Threonine', 'T'), \
            ('Tryptophan', 'W'), ('Tyrosine', 'Y'), ('Valine', 'V'))


# =================================== Define Functions ===================================

def translate(dataLocation):
    subSequence = []
    # Load the data
    with open(dataLocation, 'r') as file:  # Open the file at 'fileLocation'
        data = SeqIO.parse(file, inFileType)

        extractionIteration = 0
        # Extract the substrates
        for record in data:  # Iterate over the records
            dna = (str(record.seq))
            AA = Seq.translate(dna)

            if extractionIteration < inPrintNumberOfSubstrates:
                # Filter out sequences containing invalid or stop codons
                if 'X' and '*' not in AA:
                    if inStartSeq and inEndSeq in AA:
                        start = AA.find(inStartSeq) + len(inStartSeq)  # Find the start index
                        end = AA.find(inEndSeq)  # Find the end index
                        sub = AA[start:end].strip()
                        if len(sub) == inSubstrateLength:
                            subSequence.extend([sub])  # Record the substrate
                            print(f'Expressed Sequences: {AA}')
                            # print(f'    ')
                            print(f'    Extracted Substrates: {sub}')
                            print(f'        Extraction Iteration: {extractionIteration}')
                        extractionIteration += 1
            else:
                # Filter out sequences containing invalid or stop codons
                if 'X' and '*' not in AA:
                    if inStartSeq in AA and inEndSeq in AA:
                        start = AA.find(inStartSeq) + len(inStartSeq)  # Find the start index
                        end = AA.find(inEndSeq)  # Find the end index
                        sub = AA[start:end].strip()
                        if len(sub) == inSubstrateLength:
                            subSequence.extend([sub])  # Record the substrate

        # Verify if substrates have been extracted
        if len(subSequence) == 0:
            print('')
            print('No substrates were extracted from file at:', dataLocation)
            print('Recommend: adjust variables inStartSeq:', inStartSeq, '& inEndSeq:', inEndSeq)
            sys.exit()
        print('')
        return subSequence


def reverseTranslate(dataLocation):
    subSequence = []

    # Load the data
    with open(dataLocation, 'r') as file:  # Open the file at 'fileLocation'
        data = SeqIO.parse(file, inFileType)

        warnings.simplefilter('ignore', BiopythonWarning)

        extractionIteration = 0
        # Extract the substrates
        for record in data:  # Iterate over the records
            dna = (str(record.seq))
            revComplement = Seq(dna).reverse_complement()
            AA = str(revComplement[1:].translate())  # Seq.translate(revComplement)

            if extractionIteration < inPrintNumberOfSubstrates:
                # Filter out sequences containing invalid or stop codons
                if 'X' and '*' not in AA:
                    if inStartSeq and inEndSeq in AA:
                        start = AA.find(inStartSeq) + len(inStartSeq)  # Find the start index
                        end = AA.find(inEndSeq)  # Find the end index
                        sub = AA[start:end].strip()
                        if len(sub) == inSubstrateLength:
                            print(f'Expressed Sequences: {AA}')
                            # print(f'    ')
                            print(f'    Extracted Substrates: {sub}')
                            print(f'        Extraction Iteration: {extractionIteration}')
                            subSequence.extend([sub])  # Record the substrate
                        extractionIteration += 1
            else:
                # Filter out sequences containing invalid or stop codons
                if 'X' and '*' not in AA:
                    if inStartSeq in AA and inEndSeq in AA:
                        start = AA.find(inStartSeq) + len(inStartSeq)  # Find the start index
                        end = AA.find(inEndSeq)  # Find the end index
                        sub = AA[start:end].strip()
                        if len(sub) == inSubstrateLength:
                            subSequence.extend([sub])  # Record the substrate

        # Verify if substrates have been extracted
        if len(subSequence) == 0:
            print('')
            print('No substrates were extracted from file at:', dataLocation)
            print('Recommend: adjust variables inStartSeq:', inStartSeq, '& inEndSeq:', inEndSeq)
            sys.exit()
        print('')
        
        return subSequence


def countResidues(subs):
    # Initialize the counts matrix
    counts = np.zeros([len(residues), inSubstrateLength]).astype(int)

    # Count the occurrences of each residue
    for substrate in subs:
        if inSubstrateLength != len(substrate):
            continue
        for a in range(inSubstrateLength):
            for i, residue in enumerate(residues):
                if substrate[a] == residue[1]:
                    counts[i][a] += 1
    maxCountValue = np.max(counts)
    print(f'Maximum Residue Count: {maxCountValue}')
    print('')

    return counts


def createCustomColorMap(colorMap):
    if colorMap == inCountsColorMap:
        # Add white as the first color in the colorRange
        colorMap.insert(0, 'white')

        # Create a smooth gradient colormap with the updated colorRange
        colorList = [(i / (len(colorMap) - 1), color) for i, color in enumerate(colorMap)]
        cMapCustom = LinearSegmentedColormap.from_list('custom_colormap', colorList)
    else:
        # Create a smooth gradient colormap with the updated colorRange
        colorList = [(i / (len(colorMap) - 1), color) for i, color in enumerate(colorMap)]
        cMapCustom = LinearSegmentedColormap.from_list('custom_colormap', colorList)

    return cMapCustom


def plotCounts(counts):
    # Create heatmap
    cMapCustom = createCustomColorMap(inCountsColorMap)

    # Convert the counts to a data frame for Seaborn heatmap
    if inPrintResideName == 1:
        data = pd.DataFrame(counts, columns=inPlotResidueLabels,
                            index=[residue[0] for residue in residues])
    else:
        data = pd.DataFrame(counts, columns=inPlotResidueLabels,
                            index=[residue[1] for residue in residues])

    # Adjust the width of the figure to keep it within bounds
    figWidth = len(data.columns)
    figWidth += figWidth / 2  # Dynamically adjust the width of the figure

    # Plot the heatmap with numbers centered inside the squares
    fig, ax = plt.subplots(figsize=(figWidth, 9))
    heatmap = sns.heatmap(data, annot=True, fmt='d', cmap=cMapCustom, cbar=True,
                          linewidths=0.5, linecolor='black', square=False, center=None)
    ax.set_xlabel('Substrate Position', fontsize=inPlotLabelSize)
    ax.set_ylabel('Residue', fontsize=inPlotLabelSize)
    ax.set_yticklabels(ax.get_yticklabels(), rotation=0)
    ax.set_title(f'Residue Counts: {inSaveFileName}', fontsize=inPlotTitleSize)
    for _, spine in ax.spines.items():
        spine.set_linewidth(0.1)

    # Modify the colorbar
    cbar = heatmap.collections[0].colorbar
    cbar.outline.set_linewidth(0.5)  # Set the width of the colorbar outline to 1
    cbar.outline.set_edgecolor('black')  # Set the color of the colorbar outline to black

    plt.show()


# ===================================== RUN THE CODE =====================================

# Extract the substrates
substrates = []  # Initialize list used to record AA sequences
for fileName in inFileName:
    if '_R1_' in fileName:
        inStartSeq = 'KGS'
        inEndSeq = 'GGSGG'

        # Define file location
        fileLocation = inFilePath + '/' + fileName + '.' + inFileType
        print('File Location: ', fileLocation)

        # Extract the substrates
        subSequence = translate(fileLocation)
        substrates.extend(subSequence)
        print(f'Number of Substrates in R1: {len(substrates)}')
        print('')

    elif '_R2_' in fileName:
        inStartSeq = 'KGS'
        inEndSeq = 'GGSGG'

        # Define file location
        fileLocation = inFilePath + '/' + fileName + '.' + inFileType
        print('File Location: ', fileLocation)

        # Extract the substrates
        subSequence = reverseTranslate(fileLocation)
        substrates.extend(subSequence)
        print(f'Number of Substrates in R2: {len(substrates)}')
        print('')
print(f'Total number of Substrates: {len(substrates)}')
print('')

# Count the occurrences of each residue
counts = countResidues(substrates)

# Save counts
with open(inSavePath + inSaveFileName, 'wb') as file:
    pic.dump(counts, file)

# Determine run time
endTime = time.time()
print('Run Time: ', round((endTime - startTime), 3), 's')

# Plot the data
if inPlotCounts == 1:
    plotCounts(counts)
