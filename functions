# PURPOSE: This script contains the functions that you will need to process your NGS data



import os
import sys
import gzip
import warnings
import logomaker
import numpy as np
import pickle as pk
import pandas as pd
import seaborn as sns
from Bio import SeqIO
from Bio.Seq import Seq
from Bio import BiopythonWarning
from itertools import product
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap



# ====================================== Setup Residue List ======================================
defaultResidues = (('Alanine', 'Ala', 'A'), ('Arginine', 'Arg', 'R'), ('Asparagine', 'Asn', 'N'),
                   ('Aspartic Acid', 'Asp', 'D'), ('Cysteine', 'Cys', 'C'),
                   ('Glutamic Acid', 'Glu', 'E'), ('Glutamine', 'Gln', 'Q'),
                   ('Glycine', 'Gly', 'G'), ('Histidine', 'His ', 'H'),
                   ('Isoleucine', 'Ile', 'I'), ('Leucine', 'Leu', 'L'), ('Lysine', 'Lys', 'K'),
                   ('Methionine', 'Met', 'M'), ('Phenylalanine', 'Phe', 'F'),
                   ('Proline', 'Pro', 'P'), ('Serine', 'Ser', 'S'), ('Threonine', 'Thr', 'T'),
                   ('Tryptophan', 'Typ', 'W'), ('Tyrosine', 'Tyr', 'Y'), ('Valine', 'Val', 'V'))


# ======================================= Define Functions =======================================
class NGS:
    def __init__(self, enzymeName, substrateLength, colorsEM, colorsMotif, xAxisLabels, residueLabelType,
                 titleLabelSize, axisLabelSize, printNumber):
        self.enzymeName = enzymeName
        self.substrateLength = substrateLength  # Define the length of your substrate
        self.colorSchemeEM = colorsEM
        self.colorSchemeMotif = colorsMotif
        self.xAxisLabels = xAxisLabels
        self.residueLabelType = residueLabelType
        self.titleSize = titleLabelSize
        self.axisLabelSize = axisLabelSize
        self.residues = defaultResidues

        self.letters = [residue[2] for residue in self.residues]
        if printNumber is None:
            self.printNumber = 0
        else:
            self.printNumber = printNumber  # Define number of translated seq to print

        # Prevent data from printing in scientific notation
        np.set_printoptions(suppress=True)


    def loadAndTranslate(self, filePath, fileName, fileType, startSeq, endSeq):
        # Define file location
        if '/' in filePath:
            fileLocation = filePath + '/' + fileName + '.' + fileType
        else:
            fileLocation = filePath + '\\' + fileName + '.' + fileType

        # Determine read direction
        if '_R1_' in fileName:
            # Extract the substrates
            subSequence = NGS.translate(self, path=fileLocation, type=fileType,
                                        startSeq=startSeq, endSeq=endSeq)
        elif '_R2_' in fileName:
            # Extract the substrates
            subSequence = NGS.reverseTranslate(self, path=fileLocation, type=fileType,
                                               startSeq=startSeq, endSeq=endSeq)

        return subSequence


    def translate(self, path, type, startSeq, endSeq):
        print('============================== Translate Forward Read '
              '===============================')

        subSequence = []

        # Evaluate file path
        gZipped = False
        if not os.path.isfile(path):
            pathZipped = path + '.gz'
            if not os.path.isfile(pathZipped):
                print(f'\033[91mERROR: File location does not lead to a file'
                      f'\n     {path}\n     {pathZipped}')
                sys.exit()
            else:
                gZipped = True
                path = pathZipped
        print(f'File Location:\n     {path}\n\n')

        # Load the data & extract the substrates
        if gZipped:
            with gzip.open(path, 'rt', encoding='utf-8') as file:  # Open the file
                data = SeqIO.parse(file, type)
                warnings.simplefilter('ignore', BiopythonWarning)

                # Print expressed DNA sequences
                printedSeqs = 0
                for datapoint in data:
                    if printedSeqs == self.printNumber:
                        print()
                        break

                    DNA = str(datapoint.seq)
                    AA = Seq.translate(DNA)
                    
                    if 'X' not in AA and '*' not in AA:
                        print(f'Expressed DNA sequence: {AA}')
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                print(f'     Extracted substrate: {sub}')
                                printedSeqs += 1

                # Extract the substrates
                for datapoint in data:  # Iterate over the records
                    DNA = str(datapoint.seq)
                    AA = Seq.translate(DNA)

                    if 'X' not in AA and '*' not in AA:
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                subSequence.extend([sub])  # Record the substrate
        else:
            with open(path, 'r') as file:  # Open the file
                data = SeqIO.parse(file, type)
                warnings.simplefilter('ignore', BiopythonWarning)

                # Print expressed DNA sequences
                printedSeqs = 0
                for datapoint in data:
                    if printedSeqs == self.printNumber:
                        print()
                        break

                    DNA = str(datapoint.seq)
                    AA = Seq.translate(DNA)

                    if 'X' not in AA and '*' not in AA:
                        print(f'Expressed DNA sequence: {AA}')
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                print(f'     Extracted substrate: {sub}')
                                printedSeqs += 1

                # Extract the substrates
                for record in data:  # Iterate over the records
                    DNA = str(record.seq)
                    AA = Seq.translate(DNA)

                    # Filter out sequences containing invalid or stop codons
                    if 'X' not in AA and '*' not in AA:
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                subSequence.extend([sub])  # Record the substrate

        # Verify if substrates have been extracted
        if len(subSequence) == 0:
            print(f'\nNo substrates were extracted from file at:{path}\n'
                  f'Recommend: adjust variables'
                  f'\n     startSeq:, {startSeq}\n     endSeq: {endSeq}')
            sys.exit()
        else:
            print(f'\nNumber of Substrates in R1: {len(subSequence):,}\n\n')

        return subSequence


    def reverseTranslate(self, path, type, startSeq, endSeq):
        print('============================== Translate Reverse Read '
              '===============================')

        subSequence = []

        # Evaluate file path
        gZipped = False
        if not os.path.isfile(path):
            pathZipped = path + '.gz'
            if not os.path.isfile(pathZipped):
                print(f'\033[91mERROR: File location does not lead to a file'
                      f'\n     {path}\n     {pathZipped}')
                sys.exit()
            else:
                gZipped = True
                path = pathZipped
        print(f'File Location:\n     {path}\n\n')

        if gZipped:
            with gzip.open(path, 'rt', encoding='utf-8') as file:  # Open the file
                data = SeqIO.parse(file, type)
                warnings.simplefilter('ignore', BiopythonWarning)

                # Print expressed DNA sequences
                printedSeqs = 0
                for datapoint in data:
                    if printedSeqs == self.printNumber:
                        print()
                        break

                    DNA = str(datapoint.seq)
                    revComplement = Seq(DNA).reverse_complement()
                    AA = str(revComplement[1:].translate())

                    if 'X' not in AA and '*' not in AA:
                        print(f'Expressed DNA sequence: {AA}')
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                print(f'     Extracted substrate: {sub}')
                                printedSeqs += 1

                # Extract the substrates
                for datapoint in data:  # Iterate over the records
                    DNA = str(datapoint.seq)
                    revComplement = Seq(DNA).reverse_complement()
                    AA = str(revComplement[1:].translate())

                    # Filter out sequences containing invalid or stop codons
                    if 'X' not in AA and '*' not in AA:
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                subSequence.extend([sub])  # Record the substrate
        else:
            with open(path, 'r') as file:  # Open the file
                data = SeqIO.parse(file, type)
                warnings.simplefilter('ignore', BiopythonWarning)

                # Print expressed DNA sequences
                printedSeqs = 0
                for datapoint in data:
                    if printedSeqs == self.printNumber:
                        print()
                        break

                    DNA = str(datapoint.seq)
                    revComplement = Seq(DNA).reverse_complement()
                    AA = str(revComplement[1:].translate())

                    if 'X' not in AA and '*' not in AA:
                        print(f'Expressed DNA sequence: {AA}')
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                print(f'     Extracted substrate: {sub}')
                                printedSeqs += 1

                # Extract the substrates
                for record in data:  # Iterate over the records
                    DNA = str(record.seq)
                    revComplement = Seq(DNA).reverse_complement()
                    AA = str(revComplement[1:].translate())

                    # Filter out sequences containing invalid or stop codons
                    if 'X' not in AA and '*' not in AA:
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                subSequence.extend([sub])  # Record the substrate


        # Verify if substrates have been extracted
        if len(subSequence) == 0:
            print(f'\nNo substrates were extracted from file at:{path}\n'
                  f'Recommend: adjust variables'
                  f'\n     startSeq:, {startSeq}\n     endSeq: {endSeq}')
            sys.exit()
        else:
            print(f'\nNumber of Substrates in R2: {len(subSequence):,}\n\n')

        return subSequence


    def countResidues(self, substrates, printCounts):
        if printCounts:
            print('=============================== Calculate: AA Counts '
                  '================================')
        totalSubs = len(substrates)

        # Initialize the counts matrix
        countedData = pd.DataFrame(0, index=self.letters, columns=self.xAxisLabels, dtype=int)
        # print(f'Empty Count Matrix:\n{countedData}\n\n')

        # Count the occurrences of each residue
        for sub in substrates:
            for indexAA in range(self.substrateLength):
                if sub[indexAA] in self.letters:
                    indexResidue = self.letters.index(sub[indexAA])
                    countedData.iloc[indexResidue, indexAA] += 1
                else:
                    print(f'Outlying Substrate: {sub}\n'
                          f'     Residue: {sub[indexAA]}, Position: {indexAA}'
                          f'     self.residue: {self.letters[indexResidue]}, '
                          f'{self.letters.index(sub[indexAA])}\n')

        if printCounts:
            print(f'Counted data: {self.enzymeName}')
            print(countedData)
            print('')

        # Sanity Check: Do the sums of each column match the total number of substrates?
        columnSums = pd.DataFrame(np.sum(countedData, axis=0), columns=['Total AA Counts'],
                                  index=self.xAxisLabels)

        for indexColumn in countedData.columns:
            sum = np.sum(countedData.loc[:, indexColumn])
            if sum != totalSubs:
                print(f'\033[91mERROR: The total number of substrates ({totalSubs:,}) =/= the '
                      f'sum of column {indexColumn} ({sum:,})\n')
                sys.exit()

        print(columnSums.applymap(lambda x: '{:,}'.format(x)))
        print(f'Total number of fixed substrates: {totalSubs:,}\n\n')

        return countedData, totalSubs


    def loadSubstrates(self,filePath, fileNames, fileType, printLoadedData, printNumber):
        print('============================== Loading Substrate Files '
              '==============================')
        substrates = []
        substrateTotal = 0

        print(f'Load Files: {" ".join(fileNames)}')

        for fileName in fileNames:
            if '/' in filePath:
                fileLocation = f'{filePath}/substrates_{fileName}'
            else:
                fileLocation = f'{filePath}\\substrates_{fileName}'
            print(f'File path: {fileLocation}')

            with open(fileLocation, 'rb') as openedFile:  # Open file
                # Access the data
                data = pk.load(openedFile)

                substrates.extend(data)
                substrateTotal += len(data)

                if printLoadedData:
                    print(f'Loaded substrates from file: {fileName}')
                    for index in range(printNumber):
                        print(f'    {data[index]}')
                    print('')
        print(f'Total number of substrates in {self.enzymeName} {fileType}: '
              f'{substrateTotal:,}\n\n')

        return substrates, substrateTotal


    def fixSubstrateSequence(self, fixAA, fixPosition):
        fixResidueList = []
        for index in range(len(fixAA)):
            fixResidueList.append(f'{fixAA[index]}@R{fixPosition[index]}')
        # fixResidueList = sorted(fixResidueList, key=lambda x: int(x.split('@R')[-1]))
        # fixResiduePos = ', '.join(fixResidueList)
        # print('==================================== Fix Residues '
        #       '===================================')
        # print(f'Fix the residues:\n     {fixResiduePos}\n')

        fixedSubSeq = '_'.join(sorted([f'{fixAA[index]}@R{fixPosition[index]}'
                                       for index in range(len(fixAA))],
                                      key=lambda x: int(x.split('@R')[-1])))

        return fixedSubSeq


    def loadFixedSubstrates(self, filePath, fixAA, fixPosition, sortType, printNumber):
        # Organize the list of fixed residues
        fixResidueList = []
        for index in range(len(fixAA)):
            fixResidueList.append(f'{fixAA[index]}@R{fixPosition[index]}')
        fixResidueList = sorted(fixResidueList, key=lambda x: int(x.split('@R')[-1]))
        fixResiduePos = ', '.join(fixResidueList)
        if sortType == 'FinalSort':
            print('======================== Loading Fixed Substrates: Final Sort '
                  '=======================')
            print(f'Fix the residues:\n     {fixResiduePos}\n')
            sort = 'Final Sort'
        else:
            print('======================= Loading Fixed Substrates: Initial Sort '
                  '======================')
            print(f'Fix the residues:\n     {fixResiduePos}\n')
            sort = 'Initial Sort'

        fixedSubSeq = '_'.join(sorted(
            [f'{fixAA[index]}@R{fixPosition[index]}' for index in
             range(len(fixAA))], key=lambda x: int(x.split('@R')[-1])))

        if '/' in filePath:
            filePath = f'{filePath}/fixedSubs_{self.enzymeName}_{sortType}_Fixed_{fixedSubSeq}'
        else:
            filePath = f'{filePath}\\fixedSubs_{self.enzymeName}_{sortType}_Fixed_{fixedSubSeq}'

        # Verify that all files exist
        if os.path.exists(filePath):
            print(f'File found at path:\n     {filePath}\n\n')
            # Load the file
            with open(filePath, 'rb') as file:
                fixedSubstrates = pk.load(file)


            NGS.rankFixedSubstrates(substrates=fixedSubstrates, fixedSequence=fixedSubSeq,
                                    sortType=sort, printNumber=printNumber)
        else:
            print(f'File not found at:\n     {filePath}')
            sys.exit()


    def rankFixedSubstrates(self, substrates, fixedSequence, sortType, printNumber):
        if sortType == 'Final Sort':
            print('========================= Rank Fixed Substrates: Final Sort '
                  '=========================')
        else:
            print('======================== Rank Fixed Substrates: Initial Sort '
                  '========================')

        # Initialize fixed substrate dictionary
        fixedSubstrates = {}

        # Count the occurrences of each substrate
        for substrate in substrates:
            if substrate in fixedSubstrates:
                fixedSubstrates[substrate] += 1
            else:
                fixedSubstrates[substrate] = 1

        # Sort the substrate dictionary
        sortedFixedSubstrates = dict(sorted(fixedSubstrates.items(),
                                            key=lambda x: x[1], reverse=True))

        # Print the most prevalent sequences
        iteration = 0
        print(f'Most prevalent substrates in {sortType} with fixed: {fixedSequence}')
        for substrate, count in sortedFixedSubstrates.items():
            print(f'     {substrate}, Count: {count}')
            iteration += 1
            if iteration == printNumber:
                break
        print('\n')
        # print(f'\nTotal fixed substrates in {sortType}: {len(substrates):,}\n')


    def loadCounts(self, filePath, files, printLoadedData, fileType):
        print('=============================== Loading Counted Files '
              '===============================')
        countedData = []
        countedTotals = []
        totalSubstrateCount = 0

        # Load counted substrate data
        print(f'Load Files: {", ".join(files)}\n\n')
        for indexPath, path in enumerate(filePath):
            print(f'File path: {path}')
            with open(path, 'rb') as openedFile:  # Open file
                if indexPath == 0:

                    # Access the data
                    data = pk.load(openedFile)

                    if printLoadedData:
                        print('Loaded Data:')
                        # print(data)

                    substrateCounts = np.sum(data, axis=0)
                    countedTotals.append(substrateCounts[0])

                    countedData = data

                    print(f'    Number of substrates in {files[indexPath]}: '
                          f'{substrateCounts[indexPath]:,}\n')

                else:
                    # Access the data
                    data = pk.load(openedFile)

                    if printLoadedData:
                        print('Loaded Data:')
                        # print(data)

                    substrateCounts = np.sum(data, axis=0)
                    countedTotals.append(substrateCounts[0])

                    countedData += data  # Add the new counts to the total count

                    print(f'    Number of substrates in {files[indexPath]}: '
                          f'{substrateCounts[indexPath]:,}')
                    print('')
                totalSubstrateCount = sum(countedTotals)
        print(f'\nCounted Data From: {", ".join(files)}')
        print(f'{countedData}\n')

        # Sanity Check: Do the sums of each column match the total number of substrates?
        columnSums = pd.DataFrame(np.sum(countedData, axis=0), columns=['Column Sums'])
        for indexColumn, columnSum in enumerate(columnSums.iloc[:, 0]):
            if columnSum != totalSubstrateCount:
                columnSums = columnSums.applymap('{:,}'.format)
                print(f'{columnSums}\n')
                print(
                    f'Total number of substrates in {self.enzymeName} {fileType}: '
                    f'{totalSubstrateCount:,}\n\n')
                print(f'\033[91mERROR: The total number of substrates ({totalSubstrateCount:,}) '
                      f'=/= the sum of column {indexColumn} ({columnSum:,})\n')
                sys.exit()

        columnSums = columnSums.applymap('{:,}'.format)
        print(f'{columnSums}\n')
        print(f'Total number of substrates in {self.enzymeName} {fileType}: '
              f'{totalSubstrateCount:,}\n\n')

        return countedData, totalSubstrateCount


    def plotCounts(self, countedData, figSize, figBorders, fileName):
        # Remove commas from string values and convert to float
        countedData = countedData.applymap(lambda x:
                                           float(x.replace(',', '')) if isinstance(x, str) else x)

        # Create heatmap
        cMapCustom = NGS.createCustomColorMap(self)

        # Convert the counts to a data frame for Seaborn heatmap
        if self.residueLabelType == 0:
            countedData.index = [residue[0] for residue in self.residues]
        elif self.residueLabelType == 1:
            countedData.index = [residue[1] for residue in self.residues]
        elif self.residueLabelType == 2:
            countedData.index = [residue[2] for residue in self.residues]

        # Plot the heatmap with numbers centered inside the squares
        fig, ax = plt.subplots(figsize=figSize)
        plt.subplots_adjust(top=figBorders[0], bottom=figBorders[1], left=figBorders[2],
                            right=figBorders[3])
        heatmap = sns.heatmap(countedData, annot=True, fmt=',d', cmap=cMapCustom, cbar=True,
                              linewidths=0.5, linecolor='black', square=False, center=None)
        ax.set_xlabel('Substrate Position', fontsize=self.axisLabelSize)
        ax.set_ylabel('Residue', fontsize=self.axisLabelSize)
        ax.set_yticklabels(ax.get_yticklabels(), rotation=0)
        ax.set_title(f'Residue Counts: {fileName}', fontsize=self.titleSize)
        for _, spine in ax.spines.items():
            spine.set_visible(True)

        # Modify the colorbar
        cbar = heatmap.collections[0].colorbar
        cbar.outline.set_linewidth(0.5)  # Set the width of the colorbar outline to 1
        cbar.outline.set_edgecolor('black')  # Set the color of the colorbar outline to black

        plt.show()


    def fixResidue(self, substrates, fixedAA, fixedPosition, fixedString, printNumber, sortType):
        print('====================================== Fix AA '
              '=======================================')
        fixedSubs = []
        fixedSubsTotal = 0

        # Select substrates that contain selected AA at a specified position in the substrate
        if len(fixedAA) == 1:
            print(f'Fix Residue in {sortType}: {fixedString}\n')
            for sub in substrates:
                if sub[fixedPosition[0] - 1] == fixedAA[0]:
                    fixedSubs.append(sub)
                    fixedSubsTotal += 1
        else:
            print(f'Fix Residues in {sortType}: {fixedString}\n')
            for sub in substrates:
                saveSeq = True
                for index in range(len(fixedAA)):
                    if sub[fixedPosition[index] - 1] != fixedAA[index]:
                        saveSeq = False
                        break
                if saveSeq:
                    fixedSubs.append(sub)

        # Print fixed substrates
        print('Fixed Substrates:')
        fixedSubsTotal = len(fixedSubs)
        if fixedSubsTotal != 0:
            if fixedSubsTotal >= printNumber:
                for index in range(printNumber):
                    print(f'     {fixedSubs[index]}')
            else:
                for index in range(fixedSubsTotal):
                    print(f'     {fixedSubs[index]}')
        else:
            print('')
            print(f'\033[91mERROR: No substrates in {sortType} contained: {fixedString}\n')
            sys.exit()

        fixedSubsTotal = '{:,}'.format(fixedSubsTotal)
        print(f'\nNumber of Substrates with {fixedString}: {fixedSubsTotal}\n\n')


        return fixedSubs, fixedSubsTotal


    def createCustomColorMap(self):
        # Create a smooth gradient colormap with the updated colorRange
        colorList = [(i / (len(self.colorSchemeEM) - 1), color)
                     for i, color in enumerate(self.colorSchemeEM)]
        cMapCustom = LinearSegmentedColormap.from_list('custom_colormap', colorList)

        return cMapCustom


    def calculateRF(self, counts, N, fileType, printRF):
        # Calculate Relative Frequency of each amino acid at a given position
        RF = counts / N

        if printRF:
            print('=================================== Calculate: RF '
                  '===================================')
            print(f'Relative Frequency: {self.enzymeName} - {fileType}')
            print(np.round(RF, 4))
            print(f'\n')

        return RF


    def calculateEnrichment(self, initialSortRF, finalSortRF):
        print('============================ Calculate: Enrichment Score '
              '============================')

        initialSortRF.columns = finalSortRF.columns
        enrichment = np.log2(finalSortRF / initialSortRF)
        enrichment.columns = finalSortRF.columns
        print(f'Enrichment Score:\n{enrichment.round(3)}\n\n')

        return enrichment


    def plotEnrichmentScores(self, scores, figSize, figBorders, title, showScores, squares):
        # Create heatmap
        cMapCustom = NGS.createCustomColorMap(self)

        # Define the yLabel
        if self.residueLabelType == 0:
            scores.index = [residue[0] for residue in self.residues]
        elif self.residueLabelType == 1:
            scores.index = [residue[1] for residue in self.residues]
        elif self.residueLabelType == 2:
            scores.index = [residue[2] for residue in self.residues]

        # Find max and min values for the enrichment scores
        if np.max(scores) >= np.min(scores):
            cBarMax = np.max(scores)
            cBarMin = -1 * cBarMax
        else:
            cBarMin = np.min(scores)
            cBarMax = -1 * cBarMin


        # Plot the heatmap with numbers centered inside the squares
        fig, ax = plt.subplots(figsize=figSize)
        plt.subplots_adjust(top=figBorders[0], bottom=figBorders[1], left=figBorders[2],
                            right=figBorders[3])
        if showScores:
            heatmap = sns.heatmap(scores, annot=True, fmt='.3f', cmap=cMapCustom, cbar=True,
                                  linewidths=0.5, linecolor='black', square=squares, center=None,
                                  vmax=cBarMax, vmin=cBarMin, annot_kws={'fontweight': 'bold'})
        else:
            heatmap = sns.heatmap(scores, annot=False, cmap=cMapCustom, cbar=True, linewidths=0.5,
                                  linecolor='black', square=squares, center=None, vmax=cBarMax,
                                  vmin=cBarMin)
        ax.set_xlabel('Substrate Position', fontsize=self.axisLabelSize)
        ax.set_ylabel('Residue', fontsize=self.axisLabelSize)
        ax.set_yticklabels(ax.get_yticklabels(), rotation=0)
        ax.set_title(title, fontsize=self.titleSize, fontweight='bold')
        for _, spine in ax.spines.items():
            spine.set_visible(True)

        # Set invalid values to grey
        cmap = plt.cm.get_cmap(cMapCustom)
        cmap.set_bad(color='lightgrey')

        # Modify the colorbar
        cbar = heatmap.collections[0].colorbar
        cbar.outline.set_linewidth(0.5)  # Set the width of the colorbar outline
        cbar.outline.set_edgecolor('black')  # Set the color of the colorbar outline

        plt.show()


    def probabilityAA(self, codonSeq, printProbability):
        nucleotides = ['A', 'C', 'G', 'T']
        S = ['C', 'G']
        K = ['G', 'T']

        # Define what codons are associated with each residue
        codonsAA = {
            'A': ['GCT', 'GCC', 'GCA', 'GCG'],
            'R': ['CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'],
            'N': ['AAT', 'AAC'],
            'D': ['GAT', 'GAC'],
            'C': ['TGT', 'TGC'],
            'E': ['GAA', 'GAG'],
            'Q': ['CAA', 'CAG'],
            'G': ['GGT', 'GGC', 'GGA', 'GGG'],
            'H': ['CAT', 'CAC'],
            'I': ['ATT', 'ATC', 'ATA'],
            'L': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG'],
            'K': ['AAA', 'AAG'],
            'M': ['ATG'],
            'F': ['TTT', 'TTC'],
            'P': ['CCT', 'CCC', 'CCA', 'CCG'],
            'S': ['TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'],
            'T': ['ACT', 'ACC', 'ACA', 'ACG'],
            'W': ['TGG'],
            'Y': ['TAT', 'TAC'],
            'V': ['GTT', 'GTC', 'GTA', 'GTG']
        }

        # Initialize a list to store all possible combinations
        codons = []

        # Generate all possible combinations
        for combination in product(nucleotides, repeat=len(codonSeq)):
            # Check if the combination satisfies the conditions
            if all((c == 'N') or (c == 'S' and s in S) or (c == 'K' and s in K)
                   for c, s in zip(codonSeq, combination)):
                codons.append(''.join(combination))

        if printProbability:
            print('========================= Calculate: Residue Probabilities '
                  '=========================')
            print(f'Possible codons for {codonSeq}:')
            # Print all possible codon combinations
            for index, codon in enumerate(codons, 1):
                print(f'Codon {index}: {codon}')
            print('')

        # Count the possible codon combinations for each AA
        codonCounts = pd.DataFrame(index=self.letters, columns=['Counts'], data=0)
        for sequence in codons:
            for residue, codonsResidue in codonsAA.items():
                if sequence in codonsResidue:
                    if residue in codonCounts.index:
                        codonCounts.loc[residue, 'Counts'] += 1
                    break
        codonProbability = pd.DataFrame(index=self.letters, columns=['Probability'], data=0)
        codonProbability['Probability'] = codonCounts['Counts'] / len(codons)

        if printProbability:
            print('Amino Acid Probabilities:')
            for index, row in codonProbability.iterrows():
                print(f'     {index}    {round(row["Probability"] * 100, 2)} %')
            codonProb = round(sum(codonProbability["Probability"]) * 100, 2)
            print(f'Total probability of AA with {codonSeq}: {codonProb} %')
            print(f'Stop codon probability: {round(100 - codonProb, 2)} %\n\n')

        return codonProbability


    def heightsRF(self, counts, N, invertRF):
        print('============================= Calculate: Letter Heights '
              '=============================')
        if invertRF:
            print(f'Residue heights calculated by: RF Final Sort Inverted * ΔS\n')
        else:
            print(f'Residue heights calculated by: RF Final Sort * ΔS\n')


        fixedPositions = {}
        for indexColumn in counts.columns:
            values = counts.loc[:, indexColumn]
            if N in values.values:
                indexRow = values[values == N].index[0]
                fixedPositions[indexColumn] = indexRow
        print(f'Fixed Residues:')
        for key, value in fixedPositions.items():
            print(f'     Fixed Position: {key},  Residue: {value}')
        print('\n')

        # Print data
        print(f'Experimental Counts:\n{counts}\n\n')
        RF = counts / N
        print(f'RF - Final Sort:\n{RF.round(3)}\n\n')


        entropy = pd.DataFrame(0, index=RF.columns, columns=['ΔEntropy'])
        entropyMax = np.log2(len(RF.index))
        for indexColumn in RF.columns:
            S = 0  # Reset entropy total for a new position
            for indexRow, probRatio in RF.iterrows():
                prob = probRatio[indexColumn]
                if prob == 0:
                    continue
                else:
                    S += -prob * np.log2(prob)
            entropy.loc[indexColumn, 'ΔEntropy'] = entropyMax - S
        # print(f'{entropy}\n\nMax Entropy: {entropyMax.round(6)}\n\n')


        if invertRF:
            # print('Invert RF Values: Column Sums')
            for indexColumn in RF.columns:
                if indexColumn not in fixedPositions:
                    print(f'RF - {indexColumn} Sum: {np.round(sum(RF.loc[:, indexColumn]), 2)}')
                    RF.loc[:, indexColumn] = RF.loc[:, indexColumn] - 1
                    RF.loc[:, indexColumn] = (RF.loc[:, indexColumn] /
                                              abs(sum(RF.loc[:, indexColumn])))

                    print(f'     RF Inverted - {indexColumn} Sum: {np.round(sum(RF.loc[:, indexColumn]), 2)}')
            print('\nNOTE: Sums of the inverted RF values should be -1\n\n')
            print(f'Normalized Inverted RF:\n{RF.round(3)}')
            print('\n')

        heights = pd.DataFrame(0, index=counts.index, columns=counts.columns, dtype=float)
        for indexColumn in heights.columns:
            heights.loc[:, indexColumn] = (RF.loc[:, indexColumn] *
                                           entropy.loc[indexColumn, 'ΔEntropy'])
        print(f'Residue Heights:\n{heights.round(3)}\n\n')

        columnTotals = [[], []]
        for indexColumn in heights.columns:
            totalPos = 0
            totalNeg = 0
            for value in heights.loc[:, indexColumn]:
                if value > 0:
                    totalPos += value
                elif value < 0:
                    totalNeg += value
            columnTotals[0].append(totalPos)
            columnTotals[1].append(totalNeg)
        yMax = max(columnTotals[0])
        yMin = min(columnTotals[1])
        print(f'y Max: {np.round(yMax, 4)}, y Min: {np.round(yMin, 4)}\n\n')

        # Set values for columns with fixed residues
        for key, value in fixedPositions.items():
            heights.loc[value, key] = yMax

        return heights, fixedPositions, yMax, yMin


    def heightsRFRatio(self, counts, N, baselineProb, baselineType):
        print('============================= Calculate: Letter Heights '
              '=============================')
        print(f'Residue heights calculated by: log2(RF Ratios)\n'
              f'Baseline Probability: {baselineType}\n')

        if len(baselineProb.columns) != 1:
            baselineProb.columns = counts.columns


        fixedPositions = {}
        for indexColumn in counts.columns:
            values = counts.loc[:, indexColumn]
            if N in values.values:
                indexRow = values[values == N].index[0]
                fixedPositions[indexColumn] = indexRow
        print(f'Fixed Residues:')
        for key, value in fixedPositions.items():
            print(f'     Fixed Position: {key},  Residue: {value}')
        print('\n')

        probCounts = counts / N
        print(f'RF - Final Sort:\n{probCounts.round(3)}\n\n')
        print(f'RF - {baselineType}\n{baselineProb.round(3)}\n\n')


        probRatios = pd.DataFrame(0, index=counts.index, columns=counts.columns, dtype=float)
        if len(baselineProb.columns) == 1:
            for indexColumn in counts.columns:
                # print(f'Position: {indexColumn}')
                for indexRow in counts.index:
                    probRatio = np.log2(probCounts.loc[indexRow, indexColumn] /
                                         baselineProb.loc[indexRow, baselineProb.columns[0]])
                    probRatios.loc[indexRow, indexColumn] = probRatio
        else:
            for indexColumn in counts.columns:
                # print(f'Position: {indexColumn}')
                for indexRow in counts.index:
                    probRatio = np.log2(probCounts.loc[indexRow, indexColumn] /
                                         baselineProb.loc[indexRow, indexColumn])
                    probRatios.loc[indexRow, indexColumn] = probRatio
        probRatios.replace(-np.inf, 0, inplace=True)
        print(f'Log RF Ratios:\n{probRatios.round(3)}\n\n')


        entropy = pd.DataFrame(0, index=probCounts.columns, columns=['Entropy'])
        entropyMax = np.log2(len(probCounts.index))
        for indexColumn in probCounts.columns:
            S = 0  # Reset entropy total for a new position
            for indexRow, probRatio in probCounts.iterrows():
                prob = probRatio[indexColumn]
                if prob == 0:
                    continue
                else:
                    S += -prob * np.log2(prob)
            entropy.loc[indexColumn, 'Entropy'] = entropyMax - S
        print(f'{entropy}\n\nMax Entropy: {entropyMax.round(6)}\n\n')


        heights = pd.DataFrame(0, index=counts.index, columns=counts.columns, dtype=float)
        for indexColumn in heights.columns:
            heights.loc[:, indexColumn] = (probRatios.loc[:, indexColumn] *
                                           entropy.loc[indexColumn, "Entropy"])
        print(f'Residue Heights:\n{heights.round(3)}\n')


        columnTotals = [[], []]
        for indexColumn in heights.columns:
            totalPos = 0
            totalNeg = 0
            for value in heights.loc[:, indexColumn]:
                if value > 0:
                    totalPos += value
                elif value < 0:
                    totalNeg += value
            columnTotals[0].append(totalPos)
            columnTotals[1].append(totalNeg)
        yMax = max(columnTotals[0])
        yMin = min(columnTotals[1])
        print(f'y Max: {np.round(yMax, 4)}, y Min: {np.round(yMin, 4)}\n\n')

        # Set values for columns with fixed residues
        for key, value in fixedPositions.items():
            heights.loc[value, key] = yMax

        return heights, fixedPositions, yMax, yMin


    def plotMotif(self, data, fixedPosition, bigLettersOnTop, figureSize, figBorders, title,
                  titleSize, labelSize, yAxisLabel,  yMax, yMin):

        # Set local parameters
        tickLength = 4
        if bigLettersOnTop:
            stackOrder = 'big_on_top'
        else:
            stackOrder = 'small_on_top'
        colors = {
            'A': self.colorSchemeMotif[0],
            'R': self.colorSchemeMotif[2],
            'N': self.colorSchemeMotif[4],
            'D': self.colorSchemeMotif[1],
            'C': self.colorSchemeMotif[6],
            'E': self.colorSchemeMotif[1],
            'Q': self.colorSchemeMotif[4],
            'G': self.colorSchemeMotif[0],
            'H': self.colorSchemeMotif[2],
            'I': self.colorSchemeMotif[0],
            'L': self.colorSchemeMotif[0],
            'K': self.colorSchemeMotif[2],
            'M': self.colorSchemeMotif[6],
            'F': self.colorSchemeMotif[5],
            'P': self.colorSchemeMotif[0],
            'S': self.colorSchemeMotif[3],
            'T': self.colorSchemeMotif[3],
            'W': self.colorSchemeMotif[5],
            'Y': self.colorSchemeMotif[5],
            'V': self.colorSchemeMotif[0]
        }


        data.columns = range(len(data.columns))

        # Plot the sequence motif
        motif = logomaker.Logo(data.transpose(), color_scheme=colors,
                               width=0.95, stack_order=stackOrder, figsize=figureSize)
        plt.subplots_adjust(top=figBorders[0], bottom=figBorders[1], left=figBorders[2],
                            right=figBorders[3])

        # Set figure title
        motif.ax.set_title(title, fontsize=titleSize, fontweight='bold')

        # Set borders
        motif.style_spines(visible=False)
        motif.style_spines(spines=['left', 'bottom'], visible=True)
        for spine in motif.ax.spines.values():
            spine.set_linewidth(1.5)

        motif.ax.set_xlabel('Position', fontsize=labelSize)
        motif.ax.set_xticks([pos for pos in range(len(self.xAxisLabels))])
        motif.ax.set_xticklabels(self.xAxisLabels, rotation=0, ha='center',
                                 fontsize=labelSize - 1)

        # Set plot title "Log-Odds of the Binomial Probability"
        motif.ax.set_ylabel(yAxisLabel, fontsize=labelSize)

        # Set horizontal lines
        motif.ax.axhline(0, color='black', linestyle='-', linewidth=1.5)


        # Set yticks
        yTicks = [yMin, 0, yMax]
        motif.ax.set_yticks(yTicks)
        yTickLabels = [f'{tick:.2f}' if tick != 0 else f'{int(tick)}' for tick in yTicks]
        motif.ax.set_yticks(yTicks)
        motif.ax.set_yticklabels(yTickLabels, fontsize=labelSize - 1)
        motif.ax.tick_params(axis='y', which='major', length=tickLength)
        for tick in motif.ax.yaxis.get_major_ticks():
            tick.tick1line.set_markeredgewidth(1.5)  # Set tick width
            tick.tick2line.set_markeredgewidth(1.5)  # Set tick width


        # Evaluate dataset for fixed residues
        spacer = np.diff(motif.ax.get_xticks())  # Find the space between each tick
        spacer = spacer[0] / 2

        # Use the spacer to set a grey background to fixed residues
        for index, position in enumerate(self.xAxisLabels):
            if position in fixedPosition:
                # Plot grey boxes on each side of the xtick
                motif.ax.axvspan(index - spacer, index + spacer,
                                 facecolor='darkgrey', alpha=0.2)

        plt.show()
