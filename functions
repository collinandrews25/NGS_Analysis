# PURPOSE: This script contains the functions that you will need to process your NGS data



import os
import sys
import gzip
import warnings
import logomaker
import numpy as np
import pickle as pk
import pandas as pd
import seaborn as sns
from Bio import SeqIO
from Bio.Seq import Seq
from Bio import BiopythonWarning
from itertools import product
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap



# ====================================== Setup Residue List ======================================
defaultResidues = (('Alanine', 'Ala', 'A'), ('Arginine', 'Arg', 'R'), ('Asparagine', 'Asn', 'N'),
                   ('Aspartic Acid', 'Asp', 'D'), ('Cysteine', 'Cys', 'C'),
                   ('Glutamic Acid', 'Glu', 'E'), ('Glutamine', 'Gln', 'Q'),
                   ('Glycine', 'Gly', 'G'), ('Histidine', 'His ', 'H'),
                   ('Isoleucine', 'Ile', 'I'), ('Leucine', 'Leu', 'L'), ('Lysine', 'Lys', 'K'),
                   ('Methionine', 'Met', 'M'), ('Phenylalanine', 'Phe', 'F'),
                   ('Proline', 'Pro', 'P'), ('Serine', 'Ser', 'S'), ('Threonine', 'Thr', 'T'),
                   ('Tryptophan', 'Typ', 'W'), ('Tyrosine', 'Tyr', 'Y'), ('Valine', 'Val', 'V'))


# ======================================= Define Functions =======================================
class NGS:
    def __init__(self, enzymeName, substrateLength, colors, xAxisLabels, residueLabelType,
                 titleLabelSize, axisLabelSize, AA, printNumber):
        self.enzymeName = enzymeName
        self.substrateLength = substrateLength  # Define the length of your substrate
        self.colorScheme = colors
        self.xAxisLabels = xAxisLabels
        self.residueLabelType = residueLabelType
        self.titleSize = titleLabelSize
        self.axisLabelSize = axisLabelSize
        if AA is None:
            self.residues = defaultResidues
        else:
            self.residues = AA
        self.letters = [residue[2] for residue in self.residues]
        if printNumber is None:
            self.printNumber = 0
        else:
            self.printNumber = printNumber  # Define number of translated seq to print

        # Prevent data from printing in scientific notation
        np.set_printoptions(suppress=True)


    def loadAndTranslate(self, filePath, fileName, fileType, startSeq, endSeq):
        # Define file location
        if '/' in filePath:
            fileLocation = filePath + '/' + fileName + '.' + fileType
        else:
            fileLocation = filePath + '\\' + fileName + '.' + fileType

        # Determine read direction
        if '_R1_' in fileName:
            # Extract the substrates
            subSequence = NGS.translate(self, path=fileLocation, type=fileType,
                                        startSeq=startSeq, endSeq=endSeq)
        elif '_R2_' in fileName:
            # Extract the substrates
            subSequence = NGS.reverseTranslate(self, path=fileLocation, type=fileType,
                                               startSeq=startSeq, endSeq=endSeq)

        return subSequence


    def translate(self, path, type, startSeq, endSeq):
        print('============================== Translate Forward Read '
              '===============================')

        subSequence = []

        # Evaluate file path
        gZipped = False
        if not os.path.isfile(path):
            pathZipped = path + '.gz'
            if not os.path.isfile(pathZipped):
                print(f'\033[91mERROR: fileLocation does not lead to a file'
                      f'\n    {path}\n     {pathZipped}')
                sys.exit()
            else:
                gZipped = True
                path = pathZipped
        print(f'File Location:\n     {path}\n')

        # Load the data & extract the substrates
        if gZipped:
            with gzip.open(path, 'rt', encoding='utf-8') as file:  # Open the file
                data = SeqIO.parse(file, type)
                warnings.simplefilter('ignore', BiopythonWarning)

                # Extract the substrates
                for datapoint in data:  # Iterate over the records
                    DNA = str(datapoint.seq)
                    AA = Seq.translate(DNA)

                    # Filter out sequences containing invalid or stop codons
                    if 'X' and '*' not in AA:
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                subSequence.extend([sub])  # Record the substrate
        else:
            with open(path, 'r') as file:  # Open the file
                data = SeqIO.parse(file, type)
                warnings.simplefilter('ignore', BiopythonWarning)

                # Extract the substrates
                for record in data:  # Iterate over the records
                    DNA = str(record.seq)
                    AA = Seq.translate(DNA)

                    # Filter out sequences containing invalid or stop codons
                    if 'X' and '*' not in AA:
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                subSequence.extend([sub])  # Record the substrate

        print('Extracted Substrates:')
        for index in range(self.printNumber):
            print(f'     {subSequence[index]}')

        # Verify if substrates have been extracted
        if len(subSequence) == 0:
            print(f'\nNo substrates were extracted from file at:{path}\n'
                  f'Recommend: adjust variables'
                  f'\n     startSeq:, {startSeq}\n     endSeq: {endSeq}')
            sys.exit()
        else:
            print(f'\nNumber of Substrates in R1: {len(subSequence):,}\n\n')

        return subSequence


    def reverseTranslate(self, path, type, startSeq, endSeq):
        print('============================== Translate Reverse Read '
              '===============================')

        subSequence = []

        # Evaluate file path
        gZipped = False
        if not os.path.isfile(path):
            pathZipped = path + '.gz'
            if not os.path.isfile(pathZipped):
                print(f'\033[91mERROR: fileLocation does not lead to a file'
                      f'\n    {path}\n     {pathZipped}')
                sys.exit()
            else:
                gZipped = True
                path = pathZipped
        print(f'File Location:\n     {path}\n')

        if gZipped:
            with gzip.open(path, 'rt', encoding='utf-8') as file:  # Open the file
                data = SeqIO.parse(file, type)
                warnings.simplefilter('ignore', BiopythonWarning)

                # Extract the substrates
                for datapoint in data:  # Iterate over the records
                    DNA = str(datapoint.seq)
                    revComplement = Seq(DNA).reverse_complement()
                    AA = str(revComplement[1:].translate())

                    # Filter out sequences containing invalid or stop codons
                    if 'X' and '*' not in AA:
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                subSequence.extend([sub])  # Record the substrate
        else:
            with open(path, 'r') as file:  # Open the file
                data = SeqIO.parse(file, type)
                warnings.simplefilter('ignore', BiopythonWarning)

                # Extract the substrates
                for record in data:  # Iterate over the records
                    dna = str(record.seq)
                    revComplement = Seq(dna).reverse_complement()
                    AA = str(revComplement[1:].translate())

                    # Filter out sequences containing invalid or stop codons
                    if 'X' and '*' not in AA:
                        if startSeq in AA and endSeq in AA:
                            start = AA.find(startSeq) + len(startSeq)  # Find the start index
                            end = AA.find(endSeq)  # Find the end index
                            sub = AA[start:end].strip()
                            if len(sub) == self.substrateLength:
                                subSequence.extend([sub])  # Record the substrate

        print('Extracted Substrates:')
        for index in range(self.printNumber):
            print(f'     {subSequence[index]}')

        # Verify if substrates have been extracted
        if len(subSequence) == 0:
            print(f'\nNo substrates were extracted from file at:{path}\n'
                  f'Recommend: adjust variables'
                  f'\n     startSeq:, {startSeq}\n     endSeq: {endSeq}')
            sys.exit()
        else:
            print(f'\nNumber of Substrates in R2: {len(subSequence)}\n\n')

        return subSequence


    def countResidues(self, substrates, printCounts):
        if printCounts:
            print('=============================== Calculate: AA Counts '
                  '================================')
        totalSubs = len(substrates)

        # Initialize the counts matrix
        countedData = np.zeros((len(self.residues), int(self.substrateLength)), dtype=int)

        # Count the occurrences of each residue
        for sub in substrates:
            for idxAA in range(self.substrateLength):
                for idxR, residue in enumerate(self.residues):
                    if sub[idxAA] == residue[2]:
                        countedData[idxR][idxAA] += 1

        countedData = pd.DataFrame(countedData, index=self.letters,
                                   columns=self.xAxisLabels)

        if printCounts:
            print(f'Counted data: {self.enzymeName}')
            print(countedData)
            print('')

        # Sanity Check: Do the sums of each column match the total number of substrates?
        columnSums = pd.DataFrame(np.sum(countedData, axis=0), columns=['Total AA Counts'],
                                  index=self.xAxisLabels)

        for indexColumn in countedData.columns:
            sum = np.sum(countedData.loc[:, indexColumn])
            if sum != totalSubs:
                print(f'\033[91mERROR: The total number of substrates ({totalSubs:,}) =/= the '
                      f'sum of column {indexColumn} ({sum:,})\n')
                sys.exit()

        print(columnSums.applymap(lambda x: '{:,}'.format(x)))
        print(f'Total number of fixed substrates: {totalSubs:,}\n\n')

        return countedData, totalSubs


    def plotCounts(self, countedData, fileName):
        # Remove commas from string values and convert to float
        countedData = countedData.applymap(lambda x: float(x.replace(',', '')) if isinstance(x, str) else x)

        # Create heatmap
        cMapCustom = NGS.createCustomColorMap(self.colorScheme)

        # Convert the counts to a data frame for Seaborn heatmap
        if self.residueLabelType == 0:
            countedData.index = [residue[0] for residue in self.residues]
        elif self.residueLabelType == 1:
            countedData.index = [residue[1] for residue in self.residues]
        elif self.residueLabelType == 2:
            countedData.index = [residue[2] for residue in self.residues]

        # Adjust the width of the figure to keep it within bounds
        figWidth = len(countedData.columns)
        figWidth += figWidth / 2  # Dynamically adjust the width of the figure

        # Plot the heatmap with numbers centered inside the squares
        fig, ax = plt.subplots(figsize=(figWidth, 9))
        heatmap = sns.heatmap(countedData, annot=True, fmt=',d', cmap=cMapCustom, cbar=True,
                              linewidths=0.5, linecolor='black', square=False, center=None)
        ax.set_xlabel('Substrate Position', fontsize=self.axisLabelSize)
        ax.set_ylabel('Residue', fontsize=self.axisLabelSize)
        ax.set_yticklabels(ax.get_yticklabels(), rotation=0)
        ax.set_title(f'Residue Counts: {fileName}', fontsize=self.titleSize)
        for _, spine in ax.spines.items():
            spine.set_visible(True)

        # Modify the colorbar
        cbar = heatmap.collections[0].colorbar
        cbar.outline.set_linewidth(0.5)  # Set the width of the colorbar outline to 1
        cbar.outline.set_edgecolor('black')  # Set the color of the colorbar outline to black

        plt.show()


    def loadSubstrates(self, datasetName, filePath, fileNames, printLoadedData, printNumber):
        print('============================== Loading Substrate Files '
              '==============================')
        substrates = []
        substrateTotal = 0

        # Load counted substrate data
        print(f'Load Files: {" ".join(fileNames)}')

        for fileName in fileNames:
            if '/' in filePath:
                fileLocation = f'{filePath}/substrates_{fileName}'
            else:
                fileLocation = f'{filePath}\\substrates_{fileName}'
            print(f'File path: {fileLocation}')

            with open(fileLocation, 'rb') as openedFile:  # Open file
                # Access the data
                data = pk.load(openedFile)

                substrates.extend(data)
                substrateTotal += len(data)

                if printLoadedData:
                    print(f'Loaded substrates from file: {fileName}')
                    for idx in range(printNumber):
                        print(f'    {data[idx]}')
                    print('')
        print(f'Total number of substrates in {datasetName}: {substrateTotal:,}\n\n')

        return substrates, substrateTotal


    def loadCounts(self, filePath, files, printLoadedData, fileType):
        print('=============================== Loading Counted Files '
              '===============================')
        countedData = []
        countedTotals = []
        totalSubstrateCount = 0

        # Load counted substrate data
        print(f'Load Files: {", ".join(files)}\n\n')
        for indexPath, path in enumerate(filePath):
            print(f'File path: {path}')
            with open(path, 'rb') as openedFile:  # Open file
                if indexPath == 0:

                    # Access the data
                    data = pk.load(openedFile)

                    if printLoadedData:
                        print('Loaded Data:')
                        # print(data)

                    substrateCounts = np.sum(data, axis=0)
                    countedTotals.append(substrateCounts[0])

                    countedData = data

                    print(f'    Number of substrates in {files[indexPath]}: '
                          f'{substrateCounts[indexPath]:,}\n')

                else:
                    # Access the data
                    data = pk.load(openedFile)

                    if printLoadedData:
                        print('Loaded Data:')
                        # print(data)

                    substrateCounts = np.sum(data, axis=0)
                    countedTotals.append(substrateCounts[0])

                    countedData += data  # Add the new counts to the total count

                    print(f'    Number of substrates in {files[indexPath]}: '
                          f'{substrateCounts[indexPath]:,}')
                    print('')
                totalSubstrateCount = sum(countedTotals)
        print(f'\nCounted Data From: {", ".join(files)}')
        print(f'{countedData}\n')

        # Sanity Check: Do the sums of each column match the total number of substrates?
        columnSums = pd.DataFrame(np.sum(countedData, axis=0), columns=['Column Sums'])
        for indexColumn, columnSum in enumerate(columnSums.iloc[:, 0]):
            if columnSum != totalSubstrateCount:
                columnSums = columnSums.applymap('{:,}'.format)
                print(f'{columnSums}\n')
                print(
                    f'Total number of substrates in {self.enzymeName} {fileType}: '
                    f'{totalSubstrateCount:,}\n\n')
                print(f'\033[91mERROR: The total number of substrates ({totalSubstrateCount:,}) '
                      f'=/= the sum of column {indexColumn} ({columnSum:,})\n')
                sys.exit()

        columnSums = columnSums.applymap('{:,}'.format)
        print(f'{columnSums}\n')
        print(f'Total number of substrates in {self.enzymeName} {fileType}: '
              f'{totalSubstrateCount:,}\n\n')

        return countedData, totalSubstrateCount


    def fixResidue(self, substrates, fixedAA, printNumber):
        print('====================================== Fix AA '
              '=======================================')
        fixedSubs = []
        fixedSubsTotal = 0

        # Select substrates that contain selected AA at a specified position in the substrate
        if len(fixedAA) == 1:
            fixedResidue = fixedAA[0].split('@')[0][0]
            fixedResiduePos = int(''.join(filter(str.isdigit, fixedAA[0].split('@')[-1])))

            for sub in substrates:
                if sub[fixedResiduePos - 1] == fixedResidue:
                    fixedSubs.append(sub)
                    fixedSubsTotal += 1
        else:
            fixedResidue = []
            fixedResiduePos = []
            for fixHere in fixedAA:
                fixedResidue.append(fixHere[0].split('@')[0][0])
                pos = int(''.join(filter(str.isdigit, fixHere.split('@')[-1])))
                fixedResiduePos.append(pos)

            for sub in substrates:
                saveSeq = True
                for index in range(len(fixedResidue)):
                    if sub[fixedResiduePos[index] - 1] != fixedResidue[index]:
                        saveSeq = False
                        break

                if saveSeq:
                    fixedSubs.append(sub)

        # Print fixed substrates
        print('Fixed Substrates:')
        for index in range(printNumber):
            print(f'     {fixedSubs[index]}')
        fixedSubsTotal = len(fixedSubs)

        # Ensure you have extracted substrate with fixed AA
        if fixedSubsTotal == 0:
            print('')
            print(f'\033[91mERROR: No substrates contained {fixedAA}')
            sys.exit()

        fixedSubsTotal = '{:,}'.format(fixedSubsTotal)
        fixedAA = ', '.join(fixedAA)
        print(f'\nNumber of Substrates with {fixedAA}: {fixedSubsTotal}\n\n')


        return fixedSubs, fixedSubsTotal


    def calculateRF(self, counts, N, printRF, datasetName):
        # Calculate Relative Frequency of each amino acid at a given position
        RF = counts / N

        if printRF:
            print('=================================== Calculate: RF '
                  '===================================')
            print(f'Relative Frequency: {self.enzymeName} {datasetName}')
            print(round(RF, 4))
            print(f'\n')

        return RF


    def calculateEnrichment(self, initialSortRF, finalSortRF):
        print('============================ Calculate: Enrichment Score '
              '============================')

        initialSortRF.columns = finalSortRF.columns
        enrichment = np.log2(finalSortRF / initialSortRF)
        enrichment.columns = finalSortRF.columns
        print(f'Enrichment Score:\n{enrichment.round(3)}\n\n')

        return enrichment


    def createCustomColorMap(colorMap):
        # Create a smooth gradient colormap with the updated colorRange
        colorList = [(i / (len(colorMap) - 1), color) for i, color in enumerate(colorMap)]
        cMapCustom = LinearSegmentedColormap.from_list('custom_colormap', colorList)

        return cMapCustom


    def plotEnrichmentScores(self, scores, fileName, showValues):
        # Create heatmap
        cMapCustom = NGS.createCustomColorMap(self.colorScheme)

        # Define the yLabel
        if self.residueLabelType == 0:
            scores.index = [residue[0] for residue in self.residues]
        elif self.residueLabelType == 1:
            scores.index = [residue[1] for residue in self.residues]
        elif self.residueLabelType == 2:
            scores.index = [residue[2] for residue in self.residues]

        # Adjust the width of the figure to keep it within bounds
        figWidth = len(scores.columns)
        figWidth += figWidth / 3  # Dynamically adjust the width of the figure

        # Find max and min values for the enrichment scores
        if np.max(scores) >= np.min(scores):
            cBarMax = np.max(scores)
            cBarMin = -1 * cBarMax
        else:
            cBarMin = np.min(scores)
            cBarMax = -1 * cBarMin

        # Plot the heatmap with numbers centered inside the squares
        fig, ax = plt.subplots(figsize=(figWidth, 8))
        plt.subplots_adjust(top=0.94, bottom=0.075, left=0.12, right=0.998)
        if showValues:
            heatmap = sns.heatmap(scores, annot=True, fmt='.3f', cmap=cMapCustom, cbar=True,
                                  linewidths=0.5, linecolor='black', square=False, center=None,
                                  vmax=cBarMax, vmin=cBarMin,
                                  annot_kws={'fontweight': 'bold'})
        else:
            heatmap = sns.heatmap(scores, annot=False, cmap=cMapCustom, cbar=True, linewidths=0.5,
                                  linecolor='black', square=False, center=None, vmax=cBarMax,
                                  vmin=cBarMin)
        ax.set_xlabel('Substrate Position', fontsize=self.axisLabelSize)
        ax.set_ylabel('Residue', fontsize=self.axisLabelSize)
        ax.set_yticklabels(ax.get_yticklabels(), rotation=0)
        ax.set_title(f'{fileName} Enrichment Scores', fontsize=self.titleSize, fontweight='bold')
        for _, spine in ax.spines.items():
            spine.set_visible(True)

        # Set invalid values to grey
        cmap = plt.cm.get_cmap(cMapCustom)
        cmap.set_bad(color='lightgrey')

        # Modify the colorbar
        cbar = heatmap.collections[0].colorbar
        cbar.outline.set_linewidth(0.5)  # Set the width of the colorbar outline
        cbar.outline.set_edgecolor('black')  # Set the color of the colorbar outline

        plt.show()


    def probabilityAA(self, codonSeq, printProbability):
        nucleotides = ['A', 'C', 'G', 'T']
        S = ['C', 'G']
        K = ['G', 'T']

        # Define what codons are associated with each residue
        codonsAA = {
            'A': ['GCT', 'GCC', 'GCA', 'GCG'],
            'R': ['CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG'],
            'N': ['AAT', 'AAC'],
            'D': ['GAT', 'GAC'],
            'C': ['TGT', 'TGC'],
            'E': ['GAA', 'GAG'],
            'Q': ['CAA', 'CAG'],
            'G': ['GGT', 'GGC', 'GGA', 'GGG'],
            'H': ['CAT', 'CAC'],
            'I': ['ATT', 'ATC', 'ATA'],
            'L': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG'],
            'K': ['AAA', 'AAG'],
            'M': ['ATG'],
            'F': ['TTT', 'TTC'],
            'P': ['CCT', 'CCC', 'CCA', 'CCG'],
            'S': ['TCT', 'TCC', 'TCA', 'TCG', 'AGT', 'AGC'],
            'T': ['ACT', 'ACC', 'ACA', 'ACG'],
            'W': ['TGG'],
            'Y': ['TAT', 'TAC'],
            'V': ['GTT', 'GTC', 'GTA', 'GTG']
        }

        # Initialize a list to store all possible combinations
        codons = []

        # Generate all possible combinations
        for combination in product(nucleotides, repeat=len(codonSeq)):
            # Check if the combination satisfies the conditions
            if all((c == 'N') or (c == 'S' and s in S) or (c == 'K' and s in K)
                   for c, s in zip(codonSeq, combination)):
                codons.append(''.join(combination))

        if printProbability:
            print('========================= Calculate: Residue Probabilities '
                  '=========================')
            print(f'Possible codons for {codonSeq}:')
            # Print all possible codon combinations
            for index, codon in enumerate(codons, 1):
                print(f'Codon {index}: {codon}')
            print('')

        # Count the possible codon combinations for each AA
        codonCounts = pd.DataFrame(index=self.letters, columns=['Counts'], data=0)
        for sequence in codons:
            for residue, codonsResidue in codonsAA.items():
                if sequence in codonsResidue:
                    if residue in codonCounts.index:
                        codonCounts.loc[residue, 'Counts'] += 1
                    break
        codonProbability = pd.DataFrame(index=self.letters, columns=['Probability'], data=0)
        codonProbability['Probability'] = codonCounts['Counts'] / len(codons)

        if printProbability:
            print('Amino Acid Probabilities:')
            for index, row in codonProbability.iterrows():
                print(f'     {index}    {round(row["Probability"] * 100, 2)} %')
            codonProb = round(sum(codonProbability["Probability"]) * 100, 2)
            print(f'Total probability of AA with {codonSeq}: {codonProb} %')
            print(f'Stop codon probability: {round(100 - codonProb, 2)} %\n\n')

        return codonProbability


    def heightsRF(self, counts, N, invertRF):
        print('============================= Calculate: Letter Heights '
              '=============================')
        if invertRF:
            print(f'Residue heights calculated by: RF Final Sort Inverted * ΔS\n')
        else:
            print(f'Residue heights calculated by: RF Final Sort * ΔS\n')


        fixedPositions = {}
        for indexColumn in counts.columns:
            values = counts.loc[:, indexColumn]
            if N in values.values:
                indexRow = values[values == N].index[0]
                fixedPositions[indexColumn] = indexRow
        print(f'Fixed Residues:')
        for key, value in fixedPositions.items():
            print(f'     Fixed Position: {key},  Residue: {value}')
        print('\n')

        # Print data
        print(f'Experimental Counts:\n{counts}\n\n')
        RF = counts / N
        print(f'RF - Final Sort:\n{RF.round(3)}\n\n')


        entropy = pd.DataFrame(0, index=RF.columns, columns=['ΔEntropy'])
        entropyMax = np.log2(len(RF.index))
        for indexColumn in RF.columns:
            S = 0  # Reset entropy total for a new position
            for indexRow, probRatio in RF.iterrows():
                prob = probRatio[indexColumn]
                if prob == 0:
                    continue
                else:
                    S += -prob * np.log2(prob)
            entropy.loc[indexColumn, 'ΔEntropy'] = entropyMax - S
        # print(f'{entropy}\n\nMax Entropy: {entropyMax.round(6)}\n\n')


        if invertRF:
            # print('Invert RF Values: Column Sums')
            for indexColumn in RF.columns:
                if indexColumn not in fixedPositions:
                    print(f'RF - {indexColumn} Sum: {np.round(sum(RF.loc[:, indexColumn]), 2)}')
                    RF.loc[:, indexColumn] = RF.loc[:, indexColumn] - 1
                    RF.loc[:, indexColumn] = (RF.loc[:, indexColumn] /
                                              abs(sum(RF.loc[:, indexColumn])))

                    print(f'     RF Inverted - {indexColumn} Sum: {np.round(sum(RF.loc[:, indexColumn]), 2)}')
            print('\nNOTE: Sums of the inverted RF values should be -1\n\n')
            print(f'Normalized Inverted RF:\n{RF.round(3)}')
            print('\n')

        heights = pd.DataFrame(0, index=counts.index, columns=counts.columns, dtype=float)
        for indexColumn in heights.columns:
            heights.loc[:, indexColumn] = (RF.loc[:, indexColumn] *
                                           entropy.loc[indexColumn, 'ΔEntropy'])
        print(f'Residue Heights:\n{heights.round(3)}\n\n')

        columnTotals = [[], []]
        for indexColumn in heights.columns:
            totalPos = 0
            totalNeg = 0
            for value in heights.loc[:, indexColumn]:
                if value > 0:
                    totalPos += value
                elif value < 0:
                    totalNeg += value
            columnTotals[0].append(totalPos)
            columnTotals[1].append(totalNeg)
        yMax = max(columnTotals[0])
        yMin = min(columnTotals[1])
        print(f'y Max: {np.round(yMax, 4)}, y Min: {np.round(yMin, 4)}\n\n')

        # Set values for columns with fixed residues
        for key, value in fixedPositions.items():
            heights.loc[value, key] = yMax

        return heights, fixedPositions, yMax, yMin


    def heightsRFRatio(self, counts, N, baselineProb, baselineType):
        print('============================= Calculate: Letter Heights '
              '=============================')
        print(f'Residue heights calculated by: log2(RF Ratios)\n'
              f'Baseline Probability: {baselineType}\n')

        if len(baselineProb.columns) != 1:
            baselineProb.columns = counts.columns


        fixedPositions = {}
        for indexColumn in counts.columns:
            values = counts.loc[:, indexColumn]
            if N in values.values:
                indexRow = values[values == N].index[0]
                fixedPositions[indexColumn] = indexRow
        print(f'Fixed Residues:')
        for key, value in fixedPositions.items():
            print(f'     Fixed Position: {key},  Residue: {value}')
        print('\n')

        probCounts = counts / N
        print(f'RF - Final Sort:\n{probCounts.round(3)}\n\n')
        print(f'RF - {baselineType}\n{baselineProb.round(3)}\n\n')


        probRatios = pd.DataFrame(0, index=counts.index, columns=counts.columns, dtype=float)
        if len(baselineProb.columns) == 1:
            for indexColumn in counts.columns:
                # print(f'Position: {indexColumn}')
                for indexRow in counts.index:
                    probRatio = np.log2(probCounts.loc[indexRow, indexColumn] /
                                         baselineProb.loc[indexRow, baselineProb.columns[0]])
                    probRatios.loc[indexRow, indexColumn] = probRatio
        else:
            for indexColumn in counts.columns:
                # print(f'Position: {indexColumn}')
                for indexRow in counts.index:
                    probRatio = np.log2(probCounts.loc[indexRow, indexColumn] /
                                         baselineProb.loc[indexRow, indexColumn])
                    probRatios.loc[indexRow, indexColumn] = probRatio
        probRatios.replace(-np.inf, 0, inplace=True)
        print(f'Log RF Ratios:\n{probRatios.round(3)}\n\n')


        entropy = pd.DataFrame(0, index=probCounts.columns, columns=['Entropy'])
        entropyMax = np.log2(len(probCounts.index))
        for indexColumn in probCounts.columns:
            S = 0  # Reset entropy total for a new position
            for indexRow, probRatio in probCounts.iterrows():
                prob = probRatio[indexColumn]
                if prob == 0:
                    continue
                else:
                    S += -prob * np.log2(prob)
            entropy.loc[indexColumn, 'Entropy'] = entropyMax - S
        print(f'{entropy}\n\nMax Entropy: {entropyMax.round(6)}\n\n')


        heights = pd.DataFrame(0, index=counts.index, columns=counts.columns, dtype=float)
        for indexColumn in heights.columns:
            heights.loc[:, indexColumn] = (probRatios.loc[:, indexColumn] *
                                           entropy.loc[indexColumn, "Entropy"])
        print(f'Residue Heights:\n{heights.round(3)}\n')


        columnTotals = [[], []]
        for indexColumn in heights.columns:
            totalPos = 0
            totalNeg = 0
            for value in heights.loc[:, indexColumn]:
                if value > 0:
                    totalPos += value
                elif value < 0:
                    totalNeg += value
            columnTotals[0].append(totalPos)
            columnTotals[1].append(totalNeg)
        yMax = max(columnTotals[0])
        yMin = min(columnTotals[1])
        print(f'y Max: {np.round(yMax, 4)}, y Min: {np.round(yMin, 4)}\n\n')

        # Set values for columns with fixed residues
        for key, value in fixedPositions.items():
            heights.loc[value, key] = yMax

        return heights, fixedPositions, yMax, yMin


    def plotMotif(self, data, fixedPosition, bigLettersOnTop, yAxisLabel, figureSize, titleSize,
                  labelSize, yMax, yMin):
        # Set local parameters
        tickLength = 4
        if bigLettersOnTop:
            stackOrder = 'big_on_top'
        else:
            stackOrder = 'small_on_top'
        if yMax >= 10 or abs(yMin) >= 10:
            if yMax >= 100 or abs(yMin) >= 100:
                figLeft = 0.132
            else:
                figLeft = 0.119
        else:
            figLeft = 0.1
        colors = {
            'A': self.colorScheme[0],
            'R': self.colorScheme[2],
            'N': self.colorScheme[4],
            'D': self.colorScheme[1],
            'C': self.colorScheme[6],
            'E': self.colorScheme[1],
            'Q': self.colorScheme[4],
            'G': self.colorScheme[0],
            'H': self.colorScheme[2],
            'I': self.colorScheme[0],
            'L': self.colorScheme[0],
            'K': self.colorScheme[2],
            'M': self.colorScheme[6],
            'F': self.colorScheme[5],
            'P': self.colorScheme[0],
            'S': self.colorScheme[3],
            'T': self.colorScheme[3],
            'W': self.colorScheme[5],
            'Y': self.colorScheme[5],
            'V': self.colorScheme[0]
        }


        data.columns = range(len(data.columns))

        # Plot the sequence motif
        motif = logomaker.Logo(data.transpose(), color_scheme=colors,
                               width=0.95, stack_order=stackOrder, figsize=figureSize)
        plt.subplots_adjust(top=0.95, bottom=0.08, left=figLeft, right=0.98)

        # Set figure title
        motif.ax.set_title(f'{self.enzymeName} Sequence Motif', fontsize=titleSize,
                           fontweight='bold')

        # Set borders
        motif.style_spines(visible=False)
        motif.style_spines(spines=['left', 'bottom'], visible=True)
        for spine in motif.ax.spines.values():
            spine.set_linewidth(1.5)

        motif.ax.set_xlabel('Position', fontsize=labelSize)
        motif.ax.set_xticks([pos for pos in range(len(self.xAxisLabels))])
        motif.ax.set_xticklabels(self.xAxisLabels, rotation=0, ha='center',
                                 fontsize=labelSize - 1)

        # Set plot title "Log-Odds of the Binomial Probability"
        motif.ax.set_ylabel(yAxisLabel, fontsize=labelSize)

        # Set horizontal lines
        motif.ax.axhline(0, color='black', linestyle='-', linewidth=1.5)


        # Set yticks
        yTicks = [yMin, 0, yMax]
        motif.ax.set_yticks(yTicks)
        yTickLabels = [f'{tick:.2f}' if tick != 0 else f'{int(tick)}' for tick in yTicks]
        motif.ax.set_yticks(yTicks)
        motif.ax.set_yticklabels(yTickLabels, fontsize=labelSize - 1)
        motif.ax.tick_params(axis='y', which='major', length=tickLength)
        for tick in motif.ax.yaxis.get_major_ticks():
            tick.tick1line.set_markeredgewidth(1.5)  # Set tick width
            tick.tick2line.set_markeredgewidth(1.5)  # Set tick width


        # Evaluate dataset for fixed residues
        spacer = np.diff(motif.ax.get_xticks())  # Find the space between each tick
        spacer = spacer[0] / 2

        # Use the spacer to set a grey background to fixed residues
        for index, position in enumerate(self.xAxisLabels):
            if position in fixedPosition:
                # Plot grey boxes on each side of the xtick
                motif.ax.axvspan(index - spacer, index + spacer,
                                 facecolor='darkgrey', alpha=0.2)

        plt.show()
